# heap_exploit_learning-heap_overflow

### 1. heap overflow test code
```
#include <stdio.h>
int main(void) 
{
  char *chunk;
  chunk=malloc(24);
  puts("Get input:");
  gets(chunk);
  return 0;
}
```
用户输入的数据如果大于24字节，则数据会覆盖到下一个堆块

调试过程中，一些tips
1.64位机器最小分配的堆大小是32字节，头部16字节，用户部分16字节，比如这里的24字节，会用到分配的用户部分16字节和下一个堆块的prev_inuse部分(8字节)
2.
堆溢出是一种特定的缓冲区溢出（还有栈溢出， bss 段溢出等）。但是其与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制 EIP 。一般来说，我们利用堆溢出的策略是

! 覆盖与其物理相邻的下一个 chunk 的内容 !

    (1) prev_size
    (2) size，主要有三个比特位，以及该堆块真正的大小。
     NON_MAIN_ARENA
     IS_MAPPED  
     PREV_INUSE
     the True chunk size
    (3)chunk content
从而改变程序固有的执行流。

利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。

