## 堆中的 Off-By-One

Example:

This example introduces an off-by-one vulnerability because the boundaries of the for loop are not controlled correctly, causing the write to be executed more than once.
```
int my_gets(char *ptr,int size)
{
    int i;
    for(i=0;i<=size;i++)
    {
        ptr[i]=getchar();
    }
    return i;
}
int main()
{
    void *chunk1,*chunk2;
    chunk1=malloc(16);
    chunk2=malloc(16);
    puts("Get Input:");
    my_gets(chunk1,16);
    return 0;
}
```
This is a simple case for learning.

On the other side,there is a type of off-by-one is `NULL byte off-by-one`
ex:
```
int main(void)
{
    char buffer[40]="";
    void *chunk1;
    chunk1=malloc(24);
    puts("Get Input");
    gets(buffer);
    if(strlen(buffer)==24)
    {
        strcpy(chunk1,buffer);
    }
    return 0;

}
```

In this case while write '\x00' into dest memory,sometimes would override the low bit of heap size field.